import java.io.FileNotFoundException;
import java.util.List;
import java.util.ArrayList;

/**
 * Test class for the BruteForce class. Shows the possible word placement positions generated by
 * BruteForce for a particular board state. Also tests the genPowerset(), genPermutations()
 * and assignLettersToBlankTiles() methods.
 *
 * @author Daniel Conroy
 */
public class BruteForceTest {
    private enum SqState { OK, NOT_OK, LETTER, HOOK }
    private SqState[][] sqStates = new SqState[Board.SIZE][Board.SIZE];

    public static void main (String[] args) throws FileNotFoundException {
        BruteForceTest test = new BruteForceTest();
        BruteForce bot = new BruteForce();
        Player player = new Player();
        Board board = new Board();
        Dictionary dictionary = new Dictionary();
        List<String> powersetOfLetters;

        powersetOfLetters = bot.genPowerset("ABCDEFG");
        System.out.println("Size of powerset of letters: " + powersetOfLetters.size());
        System.out.println("\nElements of powerset:");
        for (String subsetOfLetters: powersetOfLetters) {
            if (subsetOfLetters.length() == 0) {
                System.out.print("(empty string) ");
            } else {
                System.out.print(subsetOfLetters + " ");
            }
        }
        System.out.println();

        System.out.println("\nPermutations of ABCD:");
        for (String permutation: bot.genPermutations("ABCD")) {
            System.out.print(permutation + " ");
        }
        System.out.println("\n");

        System.out.println("Letter assignments to one blank tile:");
        for (String string: bot.assignLettersToBlankTiles("*AT")) {
            System.out.print(string + " ");
        }
        System.out.println("\n");

        System.out.println("Letter assignments to two blank tiles:");
        for (String string: bot.assignLettersToBlankTiles("*A*S")) {
            System.out.print(string + " ");
        }
        System.out.println("\n");

        test.addWordToBoard(player, board, new Word(7, 5, Word.HORIZONTAL, "belated"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(5, 11, Word.VERTICAL, "hidden"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(5, 11, Word.HORIZONTAL, "hope"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(2, 13, Word.VERTICAL, "happen"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(5, 5, Word.VERTICAL, "bubble"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(5, 3, Word.HORIZONTAL, "webs"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(2, 3, Word.VERTICAL, "flew"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(4, 0, Word.HORIZONTAL, "blue"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(1, 0, Word.VERTICAL, "dabble"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(2, 6, Word.VERTICAL, "pets"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(2, 8, Word.VERTICAL, "beanbag"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(4, 8, Word.HORIZONTAL, "act"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(2, 10, Word.VERTICAL, "cat"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(1, 14, Word.VERTICAL, "get"));
        //test.displayBoardAndPositions(player, board, dictionary);
        test.addWordToBoard(player, board, new Word(1, 2, Word.VERTICAL, "pi"));
        test.displayBoardAndPositions(player, board, dictionary);
    }

    private void addWordToBoard(Player player, Board board, Word word) {
        ArrayList<Tile> tiles = new ArrayList<>();
        for (int i = 0; i < Frame.MAX_TILES; i++) {
            tiles.add(new Tile(Tile.BLANK));
        }
        player.getFrame().addTiles(tiles);
        board.setWord(word, player.getFrame());
        // All blank tiles need to be removed from the player's frame.
        while (!player.getFrame().isEmpty()) {
            player.getFrame().removeAt(0);
        }
    }

    /**
     * Displays the Scrabble board and illustrates squares on which a tile may be placed in a
     * possible word placement. This makes it easy to see that BruteForce generates all possible
     * word placement positions by comparing the list of possible word placement positions it
     * generates to the displayed board and illustrated squares.
     */
    private void displayBoardAndPositions(Player player, Board board, Dictionary dictionary) {
        BruteForce bot = new BruteForce();
        UI ui = new UI();

        System.out.println("BOARD");
        ui.displayBoard(board);
        this.displayKey();

        System.out.println("HORIZONTAL");
        this.genSqStatesHorizontal(board);
        this.displaySqStates();

        System.out.println("VERTICAL");
        this.genSqStatesVertical(board);
        this.displaySqStates();

        System.out.println("HORIZONTAL HOOKS");
        this.genSqStatesHorizontalHooks(board);
        this.displaySqStates();

        System.out.println("VERTICAL HOOKS");
        this.genSqStatesVerticalHooks(board);
        this.displaySqStates();

        bot.getCommand(player, board, dictionary);
        for (int numLetters = Frame.MAX_TILES; numLetters > 0; numLetters--) {
            List<BruteForce.Position> positions = bot.getPositions(numLetters);

            System.out.print("Possible " + numLetters + " letter positions\nHorizontal:\t");
            for (BruteForce.Position position: positions) {
                if (position.direction == Word.HORIZONTAL) {
                    System.out.print(("" + (char)(((int)'A') + position.startCol)) + (position.startRow + 1) + " ");
                }
            }
            System.out.print("\nVertical:\t");
            for (BruteForce.Position position: positions) {
                if (position.direction == Word.VERTICAL) {
                    System.out.print(("" + (char)(((int)'A') + position.startCol)) + (position.startRow + 1) + " ");
                }
            }
            System.out.println("\n");
        }
        System.out.println();
    }

    private void displayKey() {
        System.out.println(" L represents a letter");
        System.out.print(" O represents an empty square on which a tile may be placed");
        System.out.println(" as part of a possible word placement");
        System.out.print(" H represents an empty square on which a word may be 'hooked' onto");
        System.out.println(" another word on the board\n");
    }

    // Modified version of the UI.displayBoard method written by Chris Bleakley
    private void displaySqStates() {
        UI ui = new UI();
        ui.displayBoardHeader();
        System.out.println();
        for (int r = 0; r < Board.SIZE; r++) {
            System.out.printf("%2d  ", r + 1);
            for (int c = 0; c < Board.SIZE; c++) {
                switch (sqStates[r][c]) {
                    case OK:		System.out.print("O "); break;
                    case NOT_OK:	System.out.print("  "); break;
                    case LETTER:	System.out.print("L "); break;
                    case HOOK:		System.out.print("H "); break;
                }
            }
            System.out.printf("  %2d\n", r + 1);
        }
        System.out.println();
        ui.displayBoardHeader();
        System.out.println();
    }

    private void genSqStatesHorizontal(Board board) {
        this.resetSqStates();
        this.findSqStatesHorizontal(board);
    }

    private void resetSqStates() {
        for (int row = 0; row < Board.SIZE; row++) {
            for (int col = 0; col < Board.SIZE; col++) {
                sqStates[row][col] = SqState.NOT_OK;
            }
        }
    }

    private void findSqStatesHorizontal(Board board) {
        // precondition: just ran resetSqStates

        // Record letter positions and empty squares on which a word may be placed (OK squares)
        for (int row = 0; row < Board.SIZE; row++) {
            int col = 0;
            do {
                // Skip empty squares
                while (col < Board.SIZE && board.getSqContents(row, col) == Board.EMPTY)
                    col++;
                if (col == Board.SIZE) break;
                // Found a letter

                // Record OK squares preceding the letter
                for (int c = 1; c <= Frame.MAX_TILES && col >= c && sqStates[row][col - c] == SqState.NOT_OK; c++) {
                    sqStates[row][col - c] = SqState.OK;
                }

                // Record positions of this bunch of letters
                do {
                    sqStates[row][col] = SqState.LETTER;
                    col++;
                } while (col < Board.SIZE && board.getSqContents(row, col) != Board.EMPTY);
                if (col == Board.SIZE) break;
                // Found empty square after letter(s)

                // Record OK squares after the last letter
                int c;
                for (c = 0; c < Frame.MAX_TILES && col + c < Board.SIZE
                        && board.getSqContents(row, col + c) == Board.EMPTY; c++) {
                    sqStates[row][col + c] = SqState.OK;
                }
                col += c;
                // May have reached the end of the row, found another letter, or found Frame.MAX_TILES
                // consecutive empty squares (the max number of OK squares)
            } while (col < Board.SIZE);
        }
    }

    private void genSqStatesVertical(Board board) {
        this.resetSqStates();
        this.findSqStatesVertical(board);
    }

    private void findSqStatesVertical(Board board) {
        // precondition: just ran resetSqStates

        // Record letter positions and empty squares on which a word may be placed (OK squares)
        for (int col = 0; col < Board.SIZE; col++) {
            int row = 0;
            do {
                // Skip empty squares
                while (row < Board.SIZE && board.getSqContents(row, col) == Board.EMPTY)
                    row++;
                if (row == Board.SIZE) break;
                // Found a letter

                // Record OK squares preceding the letter
                for (int r = 1; r <= Frame.MAX_TILES && row >= r && sqStates[row - r][col] == SqState.NOT_OK; r++) {
                    sqStates[row - r][col] = SqState.OK;
                }

                // Record positions of this bunch of letters
                do {
                    sqStates[row][col] = SqState.LETTER;
                    row++;
                } while (row < Board.SIZE && board.getSqContents(row,col) != Board.EMPTY);
                if (row == Board.SIZE) break;
                // Found empty square after letter(s)

                // Record OK squares after the last letter
                int r;
                for (r = 0; r < Frame.MAX_TILES && row + r <Board.SIZE
                        && board.getSqContents(row + r, col) == Board.EMPTY; r++) {
                    sqStates[row + r][col] = SqState.OK;
                }
                row += r;
                // May have reached the end of the column, found another letter, or found Frame.MAX_TILES
                // consecutive empty squares (the max number of OK squares)
            } while (row < Board.SIZE);
        }
    }

    private void genSqStatesHorizontalHooks(Board board) {
        this.resetSqStates();
        this.findLetterAndHorizontalHookSqs(board);
        this.findHorizontalHookOKSqs();
    }

    private void findLetterAndHorizontalHookSqs(Board board) {
        // precondition: just ran resetSqStates

        for (int row = 0; row < Board.SIZE; row++) {
            int col = 0;
            do {
                // Check the square in the previous column, if there is one, is empty
                assert col == 0 || board.getSqContents(row, col - 1) == Board.EMPTY;

                // Search through the columns until you find a letter or a square before a letter,
                // recording hook squares along the way.
                while (col < Board.SIZE && board.getSqContents(row, col) == Board.EMPTY
                        && (col == Board.SIZE - 1 || board.getSqContents(row, col + 1) == Board.EMPTY)) {
                    if ((row > 0 && board.getSqContents(row - 1, col) != Board.EMPTY)
                            || (row < Board.SIZE - 1 && board.getSqContents(row + 1, col) != Board.EMPTY)) {
                        // There is a letter in the row above or below the current column
                        sqStates[row][col] = SqState.HOOK;
                    }
                    col++;
                }
                if (col == Board.SIZE) break;
                // Found a letter in this column or the next column

                while (col < Board.SIZE && board.getSqContents(row, col) != Board.EMPTY) {
                    sqStates[row][col] = SqState.LETTER;
                    col++;
                }
                // At the end of a bunch of letters
                col++;
            } while (col < Board.SIZE);
        }
    }

    private void findHorizontalHookOKSqs() {
        // precondition: just ran findLetterAndHorizontalHookSqs

        // Record OK squares next to horizontal hook squares
        for (int row = 0; row < Board.SIZE; row++) {
            int col = 0;
            do {
                while (col < Board.SIZE && sqStates[row][col] != SqState.HOOK)
                    col++;
                if (col == Board.SIZE) break;
                // Found a hook square

                // Record OK squares which immediately precede this hook square and which are not
                // adjacent to another letter in the same row.
                for (int c = 1; c < Frame.MAX_TILES && col >= c && sqStates[row][col - c] == SqState.NOT_OK
                        && (col == c || sqStates[row][col - c - 1] != SqState.LETTER); c++) {
                    sqStates[row][col - c] = SqState.OK;
                }

                do col++; while (col < Board.SIZE && sqStates[row][col] == SqState.HOOK);
                // At the end of this bunch of hook squares
                if (col == Board.SIZE) break;

                // Record OK squares which immediately follow this hook square and which are not
                // adjacent to another letter in the same row.
                int c;
                for (c = 0; c < Frame.MAX_TILES - 1 && col + c < Board.SIZE && sqStates[row][col + c] == SqState.NOT_OK
                        && (col + c + 1 == Board.SIZE || sqStates[row][col + c + 1] != SqState.LETTER); c++) {
                    sqStates[row][col + c] = SqState.OK;
                }
                col += c;
                // May have reached the end of the column, found another letter or hook square, or
                // found Frame.MAX_TILES-1 consecutive OK squares (the max number of OK squares).
            } while (col < Board.SIZE);
        }
    }

    private void genSqStatesVerticalHooks(Board board) {
        this.resetSqStates();
        this.findLetterAndVerticalHookSqs(board);
        this.findVerticalHookOKSqs();
    }

    private void findLetterAndVerticalHookSqs(Board board) {
        // precondition: just ran resetSqStates

        for (int col = 0; col < Board.SIZE; col++) {
            int row = 0;
            do {
                // Check the square in the previous row, if there is one, is empty
                assert row == 0 || board.getSqContents(row - 1, col) == Board.EMPTY;

                // Search through the rows until you find a letter or a square before a letter,
                // recording hook squares along the way.
                while (row < Board.SIZE && board.getSqContents(row, col) == Board.EMPTY
                        && (row == Board.SIZE - 1 || board.getSqContents(row + 1, col) == Board.EMPTY)) {
                    if ((col > 0 && board.getSqContents(row, col - 1) != Board.EMPTY)
                            || (col < Board.SIZE - 1 && board.getSqContents(row, col + 1) != Board.EMPTY)) {
                        // There is a letter in the column to the left or right of the current column.
                        sqStates[row][col] = SqState.HOOK;
                    }
                    row++;
                }
                if (row == Board.SIZE) break;
                // Found a letter in this row or the next row

                while (row < Board.SIZE && board.getSqContents(row, col) != Board.EMPTY) {
                    sqStates[row][col] = SqState.LETTER;
                    row++;
                }
                // At the end of this bunch of letters
                row++;
            } while (row < Board.SIZE);
        }
    }

    private void findVerticalHookOKSqs() {
        // precondition: just ran findLetterAndVerticalHookSqs

        // Record OK squares next to vertical hook squares
        for (int col = 0; col < Board.SIZE; col++) {
            int row = 0;
            do {
                while (row < Board.SIZE && sqStates[row][col] != SqState.HOOK)
                    row++;
                if (row == Board.SIZE) break;
                // Found a hook square

                // Record OK squares which immediately precede this hook square and which are not
                // adjacent to another letter in the same column.
                for (int r = 1; r < Frame.MAX_TILES && row >= r && sqStates[row - r][col] == SqState.NOT_OK
                        && (row == r || sqStates[row - r - 1][col] != SqState.LETTER); r++) {
                    sqStates[row - r][col] = SqState.OK;
                }

                do row++; while (row < Board.SIZE && sqStates[row][col] == SqState.HOOK);
                // At the end of this bunch of hook squares
                if (row == Board.SIZE) break;

                // Record OK squares which immediately follow this hook square and which are not
                // adjacent to another letter in the same column.
                int r;
                for (r = 0; r < Frame.MAX_TILES - 1 && row + r < Board.SIZE && sqStates[row + r][col] == SqState.NOT_OK
                        && (row + r + 1 == Board.SIZE || sqStates[row + r + 1][col] != SqState.LETTER); r++) {
                    sqStates[row + r][col] = SqState.OK;
                }
                row += r;
                // May have reached the end of the row, found another letter, or hook square, or
                // found Frame.MAX_TILES-1 consecutive OK squares (the max number of OK squares).
            } while (row < Board.SIZE);
        }
    }
}
